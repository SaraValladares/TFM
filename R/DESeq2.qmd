---
title: "RNA seq analysis temporal series"
format: html
editor: visual
autor: Sara V.
---

# DESeq2

### Librerias

No correr si ya están descargadas, a parte hay que descargarse la librería de tidyverse.

```{r}
if (!("DESeq2" %in% installed.packages())) {
  BiocManager::install("DESeq2", update = FALSE)
}
if (!("apeglm" %in% installed.packages())) {
  BiocManager::install("apeglm", update = FALSE)
}
if (!("ashr" %in% installed.packages())) {
  BiocManager::install("ashr", update = FALSE)
}

# BiocManager::install("InteractiveComplexHeatmap")
# BiocManager::install("DESeq2")
# BiocManager::install( c("GO.db", "org.At.tair.db"), force=TRUE )
# 
# BiocManager::install("apeglm")
# 
# BiocManager::install("clusterProfiler")
#
# BiocManager::install("biomartr")

# BiocManager::install("AnnotationHub")

# BiocManager::install("biomaRt", force = TRUE)

# install.packages("UpSetR")
```

#### Cargar las librerías

```{r Load Packages, include=FALSE, echo=FALSE}

library(DESeq2)
library(ggplot2)
library(magrittr)
library(tidyverse) # Desgargada a parte del resto desde los paquetes de R


library("biomaRt")
library("clusterProfiler")
library("tidyverse")
library("enrichplot")
library ("AnnotationHub")
library(UpSetR)


library(factoextra)
library(DT)
library(InteractiveComplexHeatmap)
library(ComplexHeatmap)
library(readxl)
library(gtools)
library(dplyr)
library(tidyverse)
library("DESeq2")
library("Glimma")
library("apeglm")
library("pheatmap")
library("tidyverse")
require("vidger")
library("tidyverse")
library("biomaRt")
library("ggplot2")
library("EnhancedVolcano")
library("RColorBrewer")
library("gplots")
library("amap")
library("ggplot2")
library("BiocParallel")
library("clusterProfiler")
library("MASS") 
library("reshape2") 
library("reshape")
require(DOSE)
library(enrichplot)
#library(pathview)
suppressWarnings(suppressMessages({
  #library('easypackages',warn.conflicts = FALSE, quietly=TRUE)
  library("readr",warn.conflicts = FALSE, quietly=TRUE)
  library("ggplot2",warn.conflicts = FALSE, quietly=TRUE)
  library("RColorBrewer",warn.conflicts = FALSE, quietly=TRUE)
  library("biomaRt",warn.conflicts = FALSE, quietly=TRUE)
  library("DESeq2",warn.conflicts = FALSE, quietly=TRUE)
  library("pheatmap",warn.conflicts = FALSE, quietly=TRUE)
  library("RColorBrewer",warn.conflicts = FALSE, quietly=TRUE)
  library("viridis",warn.conflicts = FALSE, quietly=TRUE)
  library("ggpubr",warn.conflicts = FALSE, quietly=TRUE)
  library('EnhancedVolcano',warn.conflicts = FALSE, quietly=TRUE)
  }))


#set seed for DESeq2::plotCounts() for reproducibility
set.seed(12345)
```

#### Path del proyecto:

```{r}
projPath="C:/Users/Sara/Desktop/TFM"
```

#### Matriz de datos de la expresión génica:

Tiene que ser un archivo csv en la que las filas sean los genes y las columnas las muestras.

Poner todas las lineas temporales de cada réplica en una misma matriz.

Comprobar que hay que hacer una por cada préplica y no una para todas a la vez.

Asegurarse que en los genes de todas las muestras están ordenados de la misma manera.

```{r}
# Reemplazar con el path al archivo con la matriz de datos
data_file <- file.path(projPath, "counts_todo.csv")
```

#### Archivo de metadatos:

Debe ser un archivo csv en el que el número de filas es igual al número de columnas de la matriz de expresión nrows(metadata) == ncols(datafile). Las columnas deben incluir la información de las variables del estudio, puntos temporales y réplicas.

Para hacer esta matriz solo se necesita la información de las distintas muestras que tenemos: DEBEN ESTAR EN EL MISMO ORDEN.

```{r}
metadata_file <- file.path(projPath, "Metadata_todo.csv")
```

Cuendo esten creados y en la carpeta correspondiente nos debería salir = TRUE en las 2.

Descomentar si se quiere utilizar.

```{r}
# # Miramos si existen los archivos que queremos dentro del directorio proporcionado
# file.exists(data_file)
# file.exists(metadata_file)
```

#### Leemos los datos:

```{r}
metadata <- readr::read_delim(metadata_file, delim = ";")

expression_galaxy <- readr::read_delim(data_file, delim = ";")

```

#### Adaptamos el formato de la matriz de expresión

```{r}
# Los nombres de cada fila tienen que ser únicos
expression_galaxy <- expression_galaxy[!(duplicated(expression_galaxy[[1]]) |
                                   duplicated(expression_galaxy[[1]], fromLast=TRUE)),]


expression_galaxy <-expression_galaxy %>%
  # Pasamos la columna de nombre de genes a ser nombres de cada fila para tener una matriz numérica con la que poder trabajar.
  tibble::column_to_rownames("Gene")
```

#### Adaptamos los metadatos:

Vamos a usar las etiquetas de inflorescencia, fruto, flor cerrada y flor abierta para marcar los distintos tiempos del experimento y así obtener nuestra línea temporal.

```{r}
metadata <- metadata %>%
  dplyr::mutate(time_stamp = dplyr::case_when(
    stringr::str_detect(Time, "IN") ~ "Inflorescencia",
    stringr::str_detect(Time, "FA") ~ "Flor_abierta",
    stringr::str_detect(Time, "FC") ~ "Flor_cerrada",
    stringr::str_detect(Time, "FR") ~ "Fruto"
  ))
```

```{r}
metadata <- metadata %>%
  dplyr::mutate(Grupo = dplyr::case_when(
    stringr::str_detect(Time, "IN") & Condition == "Control" ~ "Inflorescencia_Control",
    stringr::str_detect(Time, "IN") & Condition == "Mutante" ~ "Inflorescencia_Mutante",
    stringr::str_detect(Time, "FA") & Condition == "Control" ~ "Flor_abierta_Control",
    stringr::str_detect(Time, "FA") & Condition == "Mutante" ~ "Flor_abierta_Mutante",
    stringr::str_detect(Time, "FC") & Condition == "Control" ~ "Flor_cerrada_Control",
    stringr::str_detect(Time, "FC") & Condition == "Mutante" ~ "Flor_cerrada_Mutante",
    stringr::str_detect(Time, "FR") & Condition == "Control" ~ "Fruto_Control",
    stringr::str_detect(Time, "FR") & Condition == "Mutante" ~ "Fruto_Mutante"
  ))

```

Comprobación de que se han creado bien:

```{r}
dplyr::select(metadata, Time, time_stamp)
dplyr::select(metadata, Time, time_stamp)
```

Si tenemos en nuestros datos los tiempos desordenado con esto podemos elegir el orden que queramos en nuestra línea temporal.

```{r}
# Hacemos que la variable temporal tenga varios niveles ordenados (factor)
metadata <- metadata %>%
  dplyr::mutate(
    # Debemos poner los datos de nuestra serie temporal ordenados correctamente
    time_stamp = factor(time_stamp, levels = c("Inflorescencia", "Flor_cerrada", "Flor_abierta", "Fruto"))
  )

levels(metadata$time_stamp)
```

# DESeq2

Pasamos a usar el paquete DESeq2

#### Creamos el objeto DESeq

Creamos un objeto DESeq2 por cada una de las matrices de expresión que tengamos.

```{r}
gene_matrix <- round(expression_galaxy)

ddset <- DESeqDataSetFromMatrix(
  # Proporcionamos los datos de counts NO noramlizados
  countData = gene_matrix,
  # Proporcionamos el data frame de los metadatos como `colData` 
  colData = metadata,
  # Creamos nuestro diseño experimental con las variables de interes en: `design`
  design = ~ Time + Condition + Time:Condition # Lo hacemos en función de Tiempo, condición y la intersección entre ellos.
)
```

### Mínimo número de reads

Definimos el numéro munimo de reads que tiene que haber entre todas las ráplicas. En este caso definimos que en cada gen debe haber un mínimo de 50 reads an cualquiera de las condiciones.

Solo los genes que tengan mas de este número mínimo de reads van a ser usados para el análisis.

```{r , warning = FALSE, message = FALSE, echo = FALSE}

#Realizamos un prefiltrado mínimo para conservar únicamente las filas que tengan al menos 50 lecturas en total.

# sumamos los conteos de cada gen a lo largo de las muestras
sumcounts <- rowSums(counts(ddset))

# tomamos logaritmos
logsumcounts <- log(sumcounts,base=10)
# generamos un histograma de los conteos transformados en escala logarítmica
plot_without_filter <- hist(logsumcounts,breaks=100, main="Histograma del conteo de genes en escala logarítmica")

# obtenemos los genes con conteos mayores a 50; eliminamos los genes con baja expresión
keep <- sumcounts > 50

# conservamos solo los genes en los que 'keep' es TRUE.
ddset_filter <- ddset[keep,]

sumcounts <- rowSums(counts(ddset_filter))
# tomamos logaritmos
logsumcounts <- log(sumcounts,base=10)
# generamos un histograma de los conteos transformados en escala logarítmica filtrados

plot_with_filter <- hist(logsumcounts,breaks=100,main="Histograma del conteo de genes en escala logarítmica \n de los genes con más de 50 lecturas" )

```

## Agrupamiento de todas las muestras

Median absolute deviation (MAD) of normalized counts.

Calculate MAD: You are correctly calculating the MAD for each gene (row) in normalized_counts.

Order Normalized Counts: You sort normalized_counts based on MAD values.

Perform Log Transformation (rlog): You apply the rlog transformation to your DESeqDataSet (dds), which gives you rlogMat.

Order rlogMat Using MAD from normalized_counts: After performing the rlog, you order the rlogMat matrix by the MAD values from normalized_counts. This is where there might be some inconsistency, as the rlog values are typically used independently of the non-log transformed data.

```{r echo=, message=FALSE, warning=FALSE}

#ddsHTSeq_filter$group  <- relevel(ddsHTSeq_filter$group , ref = ref)
dds <- DESeq(ddset_filter) # <- normalize and calculate dispersion
print (dds$Grupo)
print  (resultsNames(dds))


normalized_counts <- counts(dds, normalized=TRUE)

# log transformed expression
normalized_counts_mad <- apply(normalized_counts, 1, mad)
normalized_counts <- normalized_counts[order(normalized_counts_mad, decreasing=T), ]


rld <- rlog(dds, blind=FALSE)
rlogMat <- assay(rld)

rlogMat <- rlogMat[order(normalized_counts_mad, decreasing=T), ]

# Generar color
hmcol <- colorRampPalette(brewer.pal(9, "GnBu"))(100)

 # Calcular correlación de Pearson
pearson_cor <- as.matrix(cor(rlogMat, method="pearson"))

 # Hierarchical clustering
hc <- hcluster(t(rlogMat), method="pearson")

TreeC = as.dendrogram(hc, method="average")
plot(TreeC,
     main = "Detección de muestras atípicas",
     ylab = "Height")

heatmap.2(pearson_cor, Rowv=as.dendrogram(hc), symm=T, trace="none",
col=hmcol, margins=c(11,11))

# normalized, variance-stabilized transformed counts for visualization
vsd <- vst(dds, blind=FALSE)

plotPCA(vsd, intgroup="Condition") + geom_text(aes(label=name),vjust=1.5, label.size = 0.0001 ) +  ggtitle("PCA separado por condiciones") + geom_point(size = 0.5) 

plotPCA(vsd, intgroup="Time") + geom_text(aes(label=name),vjust=1.5 ) +  ggtitle("PCA separado por tiempos") + geom_point(size = 0.5) 


plotPCA(rld, intgroup="Condition") + ggtitle("PCA Plot of Regularized log  Transformation") + geom_point(size = 4) + geom_text(aes(label=name),vjust=1.5)

pca_data <- plotPCA(rld, intgroup="Condition", returnData=T, ntop=5000)

```

# Run DESeq2

Corremos la herramienta:

```{r}
deseq_object2 <- DESeq(ddset_filter) 
```

### Matriz de counts normalizados:

```{r}
# Get normalized counts of the 2 datasets
normalized_counts <- counts(deseq_object2, normalized = TRUE)
```

#### Vemos los resultados

Vemos los resultados que obtenemos y las comparativas que estamos realizando

```{r}
deseq_results2 <- results(deseq_object2)
resultsNames(deseq_object2)

```

Si queremos ver los resultados de los primeros genes:

```{r}
head(deseq_results2)
```

#### Normalizamos los resultados mediante log fold change

Reducimos el log fold change por ashr.

```{r}
deseq_results2 <- lfcShrink(
  deseq_object2, # Este es el objeto DESeq original después de correr DESeq()
  contrast=c("Inflorescencia","Flor_cerrada","Flor_abierta", "Fruto"),
  type = "ashr",
  res = deseq_results2 # Tiene que ir la tabla de resultados original
)
head(deseq_results2)
```

#### Set up DESeq results for visualization

Convertimos los resultados a un data frame para poder visualizarlos con mayor comodidad y poder exportarlos.

Los genes aparecen ordenados me menor a mayor p_valor ajustado.

```{r}
deseq_df2 <- deseq_results2 %>%
  # En formato data frame
  as.data.frame() %>%
  # Pasamos los genes de nombres de la fila a una columna con los datos
  tibble::rownames_to_column("Gene") %>%
  # añadimos una columna que nos marca si ha pasado nuestro threshold de 0.05
  dplyr::mutate(threshold = padj < 0.05) %>%
  # Está oerdenado por valor estadístico
  dplyr::arrange(dplyr::desc(log2FoldChange))

head(deseq_df2)


###############
# Con esto sabemos que número de genes están diferencialmente expresados a un p-valor ajustado menor a 0.05

# count(deseq_df2 %>%
#    filter(threshold == "TRUE"))


```

## Visualizaciones

#### Gráfica de las counts a lo largo del tiempo de un gen determinado

Descomentar si se quiere usar

```{r}
# Comprobamos que nuestro gen de interés está en la lista de genes diferencialmente expresados

# "AT1G62380" %in% rownames(deseq_df2)
```

Guarda una imagen en la carpeta que queramos. DESCOMENTAR SI SE QUIERE USAR

```{r}
# # Dar el path y el nombre que queramos a la imagen.
# path_graficas <- "C:/Users/Sara/Desktop/Datos experimento/Datos htseq/Graficas/plot2.png"
# 
# # Abre un PNG devise
# png(path_graficas)
# 
# # Crea el plot del gen que le especifiquemos
# plotCounts(ddset_control, gene = "AT1G20440", intgroup = "time_stamp")
#
# dev.off()

```

## Guardar los resultados

Guarda la tabla entera con todos los genes y sus p-valores y el data frame de los datos normalizados y fitrados de las counts.

```{r}
readr::write_csv(
  deseq_df2,
  file.path(
    projPath,
    "diff_expr_results.tsv" # Resultados de la expresión diferencial
  )
)

deseq_df_filt <- deseq_df2 %>%
   filter(threshold == "TRUE")

normalized_counts_df <- as.data.frame(normalized_counts)


normalized_counts_df_filt <- normalized_counts_df[rownames(normalized_counts_df) %in% deseq_df_filt$Gene, ]

readr::write_csv(
  normalized_counts_df_filt,
  file.path(
    projPath,
    "normalized_counts_df_filt_deseq.tsv" # Counts normalizadas y filtradas, dataframe que se usa para clustering
  )
)


```

# Hierarchical K-means clustering

Separamos nuestros datos usando un método de clustering jerárquico: HC-Kmeans. Esto lo hacemos para buscar una estructura dentro de nuestros genes particionandolos en diferentes clusters.

```{r}
# La función hkmeans() del paquete factoextra permite aplicar el método hierarchical K-means
set.seed(101) # Para que nos de un resultado consistente y no varia cada vez que lo ejecutemos

# Datos que vamos a usar:
normalized_counts_df_filt <- normalized_counts_df[rownames(normalized_counts_df) %in% deseq_df_filt$Gene, ]

# Convertimos los nombres de fila a una columna
normalized_counts_df_filt <- tibble::rownames_to_column(normalized_counts_df_filt, var = "Gene")

##############################################
###############################
################

              # Análisis de tendencias de cada uno de los clusters #

# Realizaos un resumen de las counts
trans_cts_mean <- normalized_counts_df_filt %>% 
  # pasamos la tabla a formato largo (la giramos)
  pivot_longer(cols = CIN1:MFR4, names_to = "Muestra", values_to = "cts")  %>% 
  # juntamos la informacion con los metadatos
  full_join(metadata, by = ("Muestra")) %>% 
  # por cada gen:
  group_by(Gene) %>% 
  # escalamos cts
  mutate(cts_scaled = (cts - mean(cts))/sd(cts)) %>% 
  # para cada gen, condicion y tiempo
  group_by(Gene, Condition, time_stamp) %>%
  # calculamos la media
  summarise(mean_cts_scaled = mean(cts_scaled),
            nrep = n()) %>% 
  ungroup()


################
###############################
##############################################

##############################################
###############################
################

                          # Agrupamiento con HC kmeans #



# Creamos la matriz
hclust_matrix <- normalized_counts_df_filt %>% dplyr::select(-Gene) %>% 
  as.matrix()

# asignamos los numbres de las filas -> lista de genes
rownames(hclust_matrix) <- normalized_counts_df_filt$Gene


# Centramos y escalamos
hclust_matrix <- hclust_matrix %>% 
  # pasamos los genes a las columnas, escalamos y ponemos de nuevo la matriz en la posición original
  t() %>% 
  scale() %>% 
  t()

################################# SSE:###########################################
#Para determinar el número de clusters utilizamos es la suma del error cuadrático (SSE). La SSE se define como la suma de las distancias al cuadrado entre cada miembro de un clúster y su centroide. Pamos probnado un número creciente de clústers y evaluamos la SSE. A medida que aumentamos el número de clústers, la distancia entre cualquier punto y su centroide será menor porque el clúster es más pequeño. A partir de cierto número de clústers, la SSE ya no disminuirá significativamente con cada nuevo clúster añadido. Este punto se conoce como el codo y sugiere un número adecuado de clústers.

wss <- (nrow(hclust_matrix)-1)*sum(apply(hclust_matrix,2,var))
for (i in 2:20) wss[i] <- sum(kmeans(hclust_matrix,
                                     centers=i)$withinss)
plot(1:20, wss, type="b", xlab="Número de grupos ",
     ylab="suma de cuadrados dentro de los grupos")


hkmeans_cluster <- hkmeans(x = hclust_matrix, hc.metric = "euclidean",
                           hc.method = "complete", k = 6)

hkmeans_cluster <- hkmeans_cluster$cluster %>% 
  enframe() %>% 
  dplyr::rename(Gene = name, cluster = value)


head(hkmeans_cluster)

gene_cluster_df <- as.data.frame(hkmeans_cluster)


# Dataframe con las variables de interés
df_anotacion <- data.frame(time = metadata$Time, condition = metadata$Condition) 


# Crear anotaciones
anotacion <- HeatmapAnnotation(df = df_anotacion, show_annotation_name = FALSE)


Heatmap(matrix = hclust_matrix, name = "Z-score",
        clustering_distance_columns = "euclidean",
        clustering_distance_rows = "euclidean",
        clustering_method_columns = "complete",
        clustering_method_rows = "complete",
        split = hkmeans_cluster$cluster, show_row_names = FALSE,  column_names_gp = gpar(fontsize = 8))


ht <- Heatmap(matrix = hclust_matrix, name = "Z-score",
        clustering_distance_columns = "euclidean",
        clustering_distance_rows = "euclidean",
        clustering_method_columns = "complete",
        clustering_method_rows = "complete",
        split = hkmeans_cluster$cluster,
        cluster_columns = FALSE, # Comentar esta linea si no se quiere las muestras ordenadas.
        top_annotation = anotacion, show_row_names = FALSE,  column_names_gp = gpar(fontsize = 8), show_column_dend = FALSE)


ht

#htShiny(ht) # Esto nos genera un Heatmap Interactivo en el que podemos hacer zoom en las zonas que más nos interesan

gene_cluster <- hkmeans_cluster

genes_cluster_1 <- gene_cluster %>% filter(cluster==1)
genes_cluster_1_list <- genes_cluster_1 %>% dplyr::select(Gene)
readr::write_csv(genes_cluster_1_list, "genes_cluster_1.csv")

genes_cluster_2 <- gene_cluster %>% filter(cluster==2)
genes_cluster_2_list <- genes_cluster_2 %>% dplyr::select(Gene)
readr::write_csv(genes_cluster_2_list, "genes_cluster_2.csv")

genes_cluster_3 <- gene_cluster %>% filter(cluster==3)
genes_cluster_3_list <- genes_cluster_3 %>% dplyr::select(Gene)
readr::write_csv(genes_cluster_3_list, "genes_cluster_3.csv")

genes_cluster_4 <- gene_cluster %>% filter(cluster==4)
genes_cluster_4_list <- genes_cluster_4 %>% dplyr::select(Gene)
readr::write_csv(genes_cluster_4_list, "genes_cluster_4.csv")

genes_cluster_5 <- gene_cluster %>% filter(cluster==5)
genes_cluster_5_list <- genes_cluster_5 %>% dplyr::select(Gene)
readr::write_csv(genes_cluster_5_list, "genes_cluster_5.csv")

genes_cluster_6 <- gene_cluster %>% filter(cluster==6)
genes_cluster_6_list <- genes_cluster_6 %>% dplyr::select(Gene)
readr::write_csv(genes_cluster_6_list, "genes_cluster_6.csv")

```

## Tendencias de expresión de cada cluster:

```{r}

trans_cts_cluster <- trans_cts_mean %>% 
  inner_join(hkmeans_cluster, by = "Gene")

head(trans_cts_cluster)


# Añadimos una linea que indica la expresión media de cada cluster
trans_cts_cluster %>%
  ggplot (aes(x=factor(time_stamp, level=c('Inflorescencia', 'Flor_cerrada', 'Flor_abierta', 'Fruto')), y=mean_cts_scaled)) +
  geom_line(aes(group = Gene), alpha = 0.3) +
  geom_line(stat = "summary", fun = "median", colour = "brown", size = 1.5, aes(group = 1)) +
  facet_grid(rows = vars(Condition), cols = vars(cluster)) +
  xlab('Time')

```

# Gene Ontology enrichment analysis

Análisis Gene Ontology ORA usando clusterProfiler

-\> Over Representation Analysis (ORA)

El análisis de sobrerrepresentación conssnte en buscar rutas o funciones biologógicas enriquecidas en los grupos de genes proporcionados (obtenidos en nuestro análisis expresimental) cuendo lo comparamos con una lista de funciones y rutas.

Los recursos que podemos obtener en un Gene Ontology se dividen en 3 sub-dominios:

-   Procesos biológicos (BP): eventos moleculares con un comienzo y final definido que son relevantes para la funcion del organismo o de la célula.
-   Componenete Celular (CC): A qué parte de la célula pertenece.
-   Función molecular (MF): La función enzimática de un producto.

```{r}
hub <- AnnotationHub()

query(hub, c("Arabidopsis thaliana", "orgdb"))

a_thaliana <- hub [["AH116702"]]

keytypes(a_thaliana)
#keys(a_thaliana)
columns(a_thaliana)

```

```{r}

mart <- useMart(biomart="plants_mart", host="https://plants.ensembl.org")

listdatasets <- listDatasets(mart)
(listDatasets(mart))[grep("athaliana_eg_gene",listDatasets(mart)[,1]),]
athaliana_mart <- useMart(biomart = "plants_mart", host = "https://plants.ensembl.org", dataset = "athaliana_eg_gene"	)
listAttributes <- listAttributes(mart = athaliana_mart, page="feature_page")
listAttributes

# Construimos un universo con nuestros genes

attributes_to_retrieve = c("entrezgene_id", "external_gene_name", "name_1006", "go_id", "definition_1006") # Que informacion queremos recuperar

all_athaliana_genes <- biomartr::biomart(genes = deseq_df2$Gene, mart = "plants_mart",   dataset = "athaliana_eg_gene",  attributes = attributes_to_retrieve, filters =  "ensembl_gene_id" )  # Lo hacemos con todos los genes filtrados que han entrado a DESEQ

all_athaliana_genes$entrezgene_id = as.character(all_athaliana_genes$entrezgene_id) 
# Añadimos la infromación de la descripción del gen y el simbolo de TAIR
attributes_annotation = c("description", "tair_symbol")

resdata_annotation <- biomartr::biomart(genes = gene_cluster$Gene, mart = "plants_mart",   dataset = "athaliana_eg_gene",  attributes = attributes_annotation, filters =  "ensembl_gene_id" )  # Esto lo hacemos con los genes diferencialmetne expresados

resdata_annotationClean <- resdata_annotation[!duplicated(resdata_annotation$ensembl_gene_id),]
resdata_annotationClean # Limpiamos los datos

resdata_with_annotation <- merge(gene_cluster,resdata_annotationClean, by.x = "Gene", by.y= "ensembl_gene_id" )

# Creamos la tabla que podemos descargar
DT::datatable(resdata_with_annotation, class = 'cell-border stripe', editable = TRUE,extensions = 'Buttons', options = list(dom = 'Bfrtip', buttons = c('copy', 'csv', 'excel', 'pdf', 'print')), filter = "top", rownames = F)

```

## Clusters de los grupos uno por uno:

### Cluster 1:

```{r}
# Recuperamos el identificador Entrez de NCBI para nuestros genes defirencialmente expresados de cada grupo
cluster_1_athaliana_genes_annotated<- biomartr::biomart(genes = genes_cluster_1$Gene,                  # genes were retrieved using biomartr::getGenome()
                                mart = "plants_mart",                     # marts were selected with biomartr::getMarts()
                                dataset = "athaliana_eg_gene",               # datasets were selected with biomartr::getDatasets()
                                attributes = attributes_to_retrieve,            # attributes were selected with biomartr::getAttributes()
                                filters =   "ensembl_gene_id" )# clave de la consulta
head(cluster_1_athaliana_genes_annotated)  

# Realizamos el análisis de sobrerrepresentación (ORA) para la categoría de Proceso Biológico en GO
ora_analysis_bp <- enrichGO(gene = cluster_1_athaliana_genes_annotated$entrezgene_id, 
                            universe = all_athaliana_genes$entrezgene_id, 
                            OrgDb = a_thaliana,  #  correspondencia entre los identificadores TAIR/Ensembl y GO para A. thaliana
                            keyType = "ENTREZID",
                            ont = "BP",              #  "BP", "CC" o "MF" Se puede cambiar según la consulta
                            pAdjustMethod = "BH",
                            qvalueCutoff = 0.05,
                            readable = TRUE, 
                            pool = FALSE)

ora_analysis_bp_simplify <- clusterProfiler::simplify(ora_analysis_bp, cutoff=0.6, by="p.adjust", select_fun=min)

ora_analysis_bp_df_C1 <- ora_analysis_bp@result  %>% tibble::rownames_to_column("GO") %>% filter(p.adjust<=0.05)
readr::write_csv(ora_analysis_bp_df_C1, "ora_analysis_athaliana_res_cluster_1_entrezid.csv")

# Creamos la tabla con los datos para que sea más sencillo analizarlos en profundidad
DT::datatable(ora_analysis_bp_df_C1, class = 'cell-border stripe', editable = TRUE,extensions = 'Buttons', options = list(dom = 'Bfrtip', buttons = c('copy', 'csv', 'excel', 'pdf', 'print')), filter = "top", rownames = F)

barplot(ora_analysis_bp_simplify, 
        drop = TRUE, 
        showCategory = 10, 
        title = "Procesos biológicos GO - Grupo 1",
        font.size = 14)# Ajustamos el tamaño de letra dependiendo de si se sobrepone

```

### Cluster 2:

```{r}
cluster_2_athaliana_genes_annotated<- biomartr::biomart(genes = genes_cluster_2$Gene,                  # genes were retrieved using biomartr::getGenome()
                                mart = "plants_mart",                     # marts were selected with biomartr::getMarts()
                                dataset = "athaliana_eg_gene",               # datasets were selected with biomartr::getDatasets()
                                attributes = attributes_to_retrieve,            # attributes were selected with biomartr::getAttributes()
                                filters =   "ensembl_gene_id" )
head(cluster_2_athaliana_genes_annotated)  

ora_analysis_bp <- enrichGO(gene = cluster_2_athaliana_genes_annotated$entrezgene_id, 
                            universe = all_athaliana_genes$entrezgene_id, 
                            OrgDb = a_thaliana,  
                            keyType = "ENTREZID",
                            ont = "BP",              
                            pAdjustMethod = "BH",
                            qvalueCutoff = 0.05,
                            readable = TRUE, 
                            pool = FALSE)

ora_analysis_bp_simplify <- clusterProfiler::simplify(ora_analysis_bp, cutoff=0.6, by="p.adjust", select_fun=min)

ora_analysis_bp_df_C2 <- ora_analysis_bp@result  %>% tibble::rownames_to_column("GO") %>% filter(p.adjust<=0.05)
readr::write_csv(ora_analysis_bp_df_C2, "ora_analysis_athaliana_res_cluster_2_entrezid.csv")

DT::datatable(ora_analysis_bp_df_C2, class = 'cell-border stripe', editable = TRUE,extensions = 'Buttons', options = list(dom = 'Bfrtip', buttons = c('copy', 'csv', 'excel', 'pdf', 'print')), filter = "top", rownames = F)

barplot(ora_analysis_bp_simplify, 
        drop = TRUE, 
        showCategory = 10, 
        title = "Procesos biológicos GO - Grupo 2",
        font.size = 14)

```

### Cluster 3:

```{r}

cluster_3_athaliana_genes_annotated<- biomartr::biomart(genes = genes_cluster_3$Gene,                  # genes were retrieved using biomartr::getGenome()
                                mart = "plants_mart",                     # marts were selected with biomartr::getMarts()
                                dataset = "athaliana_eg_gene",               # datasets were selected with biomartr::getDatasets()
                                attributes = attributes_to_retrieve,            # attributes were selected with biomartr::getAttributes()
                                filters =   "ensembl_gene_id" )
head(cluster_3_athaliana_genes_annotated)  

# performing the ORA for Gene Ontology Biological Process class
ora_analysis_bp <- enrichGO(gene = cluster_3_athaliana_genes_annotated$entrezgene_id, 
                            universe = all_athaliana_genes$entrezgene_id, 
                            OrgDb = a_thaliana, 
                            keyType = "ENTREZID",
                            ont = "BP",             
                            pAdjustMethod = "BH",
                            qvalueCutoff = 0.05,
                            readable = TRUE, 
                            pool = FALSE)



ora_analysis_bp_simplify <- clusterProfiler::simplify(ora_analysis_bp, cutoff=0.6, by="p.adjust", select_fun=min)

ora_analysis_bp_df_C3 <- ora_analysis_bp@result  %>% tibble::rownames_to_column("GO") %>% filter(p.adjust<=0.05)
readr::write_csv(ora_analysis_bp_df_C3, "ora_analysis_athaliana_res_cluster_3_entrezid.csv")

DT::datatable(ora_analysis_bp_df_C3, class = 'cell-border stripe', editable = TRUE,extensions = 'Buttons', options = list(dom = 'Bfrtip', buttons = c('copy', 'csv', 'excel', 'pdf', 'print')), filter = "top", rownames = F)

barplot(ora_analysis_bp_simplify, 
        drop = TRUE, 
        showCategory = 10, # Podemos quitar categorias si se nos sobreponen o hay demasiadas
        title = "Procesos biológicos GO - Grupo 3",
        font.size = 9)


```

### Cluster 4:

```{r}

cluster_4_athaliana_genes_annotated<- biomartr::biomart(genes = genes_cluster_4$Gene,                  # genes were retrieved using biomartr::getGenome()
                                mart = "plants_mart",                     # marts were selected with biomartr::getMarts()
                                dataset = "athaliana_eg_gene",               # datasets were selected with biomartr::getDatasets()
                                attributes = attributes_to_retrieve,            # attributes were selected with biomartr::getAttributes()
                                filters =   "ensembl_gene_id" )
head(cluster_4_athaliana_genes_annotated)  

ora_analysis_bp <- enrichGO(gene = cluster_4_athaliana_genes_annotated$entrezgene_id, 
                            universe = all_athaliana_genes$entrezgene_id, 
                            OrgDb = a_thaliana,  
                            keyType = "ENTREZID",
                            ont = "BP",              
                            pAdjustMethod = "BH",
                            qvalueCutoff = 0.05,
                            readable = TRUE, 
                            pool = FALSE)



ora_analysis_bp_simplify <- clusterProfiler::simplify(ora_analysis_bp, cutoff=0.6, by="p.adjust", select_fun=min)

ora_analysis_bp_df_C4 <- ora_analysis_bp@result  %>% tibble::rownames_to_column("GO") %>% filter(p.adjust<=0.05)
readr::write_csv(ora_analysis_bp_df_C4, "ora_analysis_athaliana_res_cluster_4_entrezid.csv")

DT::datatable(ora_analysis_bp_df_C4, class = 'cell-border stripe', editable = TRUE,extensions = 'Buttons', options = list(dom = 'Bfrtip', buttons = c('copy', 'csv', 'excel', 'pdf', 'print')), filter = "top", rownames = F)

barplot(ora_analysis_bp_simplify, 
        drop = TRUE, 
        showCategory = 10, 
        title = "Procesos biológicos GO - Grupo 4",
        font.size = 14)


```

### Cluster 5:

```{r}

cluster_5_athaliana_genes_annotated<- biomartr::biomart(genes = genes_cluster_5$Gene,                  # genes were retrieved using biomartr::getGenome()
                                mart = "plants_mart",                     # marts were selected with biomartr::getMarts()
                                dataset = "athaliana_eg_gene",               # datasets were selected with biomartr::getDatasets()
                                attributes = attributes_to_retrieve,            # attributes were selected with biomartr::getAttributes()
                                filters =   "ensembl_gene_id" )
head(cluster_5_athaliana_genes_annotated)  

ora_analysis_bp <- enrichGO(gene = cluster_5_athaliana_genes_annotated$entrezgene_id, 
                            universe = all_athaliana_genes$entrezgene_id, 
                            OrgDb = a_thaliana,  
                            keyType = "ENTREZID",
                            ont = "BP",              
                            pAdjustMethod = "BH",
                            qvalueCutoff = 0.05,
                            readable = TRUE, 
                            pool = FALSE)



ora_analysis_bp_simplify <- clusterProfiler::simplify(ora_analysis_bp, cutoff=0.6, by="p.adjust", select_fun=min)

ora_analysis_bp_df_C5 <- ora_analysis_bp@result  %>% tibble::rownames_to_column("GO") %>% filter(p.adjust<=0.05)
readr::write_csv(ora_analysis_bp_df_C5, "ora_analysis_athaliana_res_cluster_5_entrezid.csv")

DT::datatable(ora_analysis_bp_df_C5, class = 'cell-border stripe', editable = TRUE,extensions = 'Buttons', options = list(dom = 'Bfrtip', buttons = c('copy', 'csv', 'excel', 'pdf', 'print')), filter = "top", rownames = F)

barplot(ora_analysis_bp_simplify, 
        drop = TRUE, 
        showCategory = 10, 
        title = "Procesos biológicos GO - Grupo 5",
        font.size = 14)


```

### Cluster 6:

```{r}
cluster_6_athaliana_genes_annotated<- biomartr::biomart(genes = genes_cluster_6$Gene,                  # genes were retrieved using biomartr::getGenome()
                                mart = "plants_mart",                     # marts were selected with biomartr::getMarts()
                                dataset = "athaliana_eg_gene",               # datasets were selected with biomartr::getDatasets()
                                attributes = attributes_to_retrieve,            # attributes were selected with biomartr::getAttributes()
                                filters =   "ensembl_gene_id" )
head(cluster_6_athaliana_genes_annotated)  

ora_analysis_bp <- enrichGO(gene = cluster_6_athaliana_genes_annotated$entrezgene_id, 
                            universe = all_athaliana_genes$entrezgene_id, 
                            OrgDb = a_thaliana,  
                            keyType = "ENTREZID",
                            ont = "BP",              
                            pAdjustMethod = "BH",
                            qvalueCutoff = 0.05,
                            readable = TRUE, 
                            pool = FALSE)



ora_analysis_bp_simplify <- clusterProfiler::simplify(ora_analysis_bp, cutoff=0.6, by="p.adjust", select_fun=min)

ora_analysis_bp_df_C6 <- ora_analysis_bp@result  %>% tibble::rownames_to_column("GO") %>% filter(p.adjust<=0.05)
readr::write_csv(ora_analysis_bp_df_C6, "ora_analysis_athaliana_res_cluster_6_entrezid.csv")

DT::datatable(ora_analysis_bp_df_C6, class = 'cell-border stripe', editable = TRUE,extensions = 'Buttons', options = list(dom = 'Bfrtip', buttons = c('copy', 'csv', 'excel', 'pdf', 'print')), filter = "top", rownames = F)

barplot(ora_analysis_bp_simplify, 
        drop = TRUE, 
        showCategory = 10, 
        title = "Procesos biológicos GO - Grupo 6",
        font.size = 14)

```

### Visualización de la expresión de genes en concreto

Si queremos comparar alguno de los genes visualmente:

```{r}
# Ejemplo de un gen diferencial,ente expresado tanto en control como en mutante
# pero con perfiles temporales muy diferentes.

count_data = plotCounts(ddset_filter, gene = "AT1G18750", intgroup = c("time_stamp", "Condition"), returnData = TRUE)

ggplot(count_data, aes(x = time_stamp, y = count, color = Condition, group = Condition)) +
  geom_point(size = 3) +  # Adjust point size
  geom_line() +           # Add a line connecting points
  theme_minimal() +
  labs(title = "Expresión del gen: AT1G18750",
       x = "Tiempo",
       y = "Counts normalizadas") +
  scale_color_manual(values = c("red", "blue"))  # Customize colors

```

# Tablas Resultados

```{r}
# Neasitamos unir la información de 3 tablas: de resdata con anotaciones necesitamos todas las columnas, de deseq
# deseq_df_filt (resultados) necesitamos la columna de log2foldchange y de la matriz normalized counts _df_filt queremos meter
# todas las counts normalizadas 

# Esto debemos ordenarlo por Gene.


# Hacemos copias de los DF que queremos especificando las columnas
df1 <- resdata_with_annotation
df2 <- deseq_df_filt[, c("Gene", "log2FoldChange")]
df3 <- normalized_counts_df_filt

# Hacemos un merge de las columnas usando "Gene"
merged_df <- merge(merge(df1, df2, by = "Gene"), df3, by = "Gene")

# Ordenamos los resultados por la columna "Gene"
merged_df <- merged_df[order(merged_df$Gene), ]

# Guardar la tabla:

DT::datatable(merged_df, class = 'cell-border stripe', editable = TRUE,extensions = 'Buttons', options = list(dom = 'Bfrtip', buttons = c('copy', 'csv', 'excel', 'pdf', 'print')), filter = "top", rownames = F)


```

# Matriz Mahalanobis con los datos de genes

Vamos a usar distancias de Mahalanobis para clusterizar otra vez los datos y ver si se obtiene algo distinto.

Estamos sacando las distancias de Mahalanovis usando todos los datos de cada gen (de cada tiempo y codición combinados) lo que nos resume todos los datos en una única variante ( lo vuelve un análisis univariante y eso tiene sus problemas con la fiabilidad estdística también).

## Medias de las réplicas

```{r}


  ############## SIN LAS RÉPLICAS #################
# Pasar las replicas de las counts a un consenso para hacer la matriz de Mahalanobis.
# Si no nos queda con mucho ruido.

### Cargamos los metadatos de las medias: 

metadata_file_mean <- file.path(projPath, "Metadata_mean.csv")
metadata_mean <- readr::read_delim(metadata_file_mean, delim = ";")


normalized_counts_filt_matrix <- as.matrix(normalized_counts_df_filt[, !(names(normalized_counts_df_filt) == "Gene")])


# Extraemos las primeras 3 letras de los nombres de las columnas.
condiciones <- substr(colnames(normalized_counts_filt_matrix), 1, 3)

# Hacemos la media de las répplicas de cada condicion
normalized_counts_filt_matrix_mean <- sapply(unique(condiciones), function(cond) {
  rowMeans(normalized_counts_filt_matrix[, condiciones == cond, drop = FALSE])
})

##############################################################################

compute_mahalanobis_row <- function(row) {
  n <- length(row)
  var_row <- var(row)  # variancia de la linea
  dist_matrix <- matrix(0, n, n)  # Inicializamos una matriz de distancias vacia
  
  # vamops generando las distancias a cada par de datos
  for (i in 1:n) {
    for (j in 1:n) {
      dist_matrix[i, j] <- (row[i] - row[j])^2 / var_row  # Apicamos la formula de mahalanobis (estamos dividiendo entre la varianza de toda la fila)
    }
  }

  
  return(dist_matrix)
}

# Aplicamos esto a todas las filas
result <- lapply(1:nrow(normalized_counts_filt_matrix_mean), function(i) compute_mahalanobis_row(normalized_counts_filt_matrix_mean[i, ]))



# Hacemos la media de cada linea de las matrices de distancia de Mahalanobis.
compute_row_means <- function(mahal_matrix_list) {
  # Tenemos una matriz vacía para guardar las medias
  num_rows <- length(mahal_matrix_list) # Elo numero ed líneas debe coincidir con el numero de matrices de distancias que tenemos, que será igual a nuestro numero de genes  (cada linea seria un gen)
  num_cols <- ncol(mahal_matrix_list[[1]]) # El número de columnas será las diferentes condiciones que tenemos
  
  mean_matrix <- matrix(0, nrow = num_rows, ncol = num_cols) # Cremos una matriz vacia para los datos
  
  for (i in 1:num_rows) {
    # Compute the mean for each column in the Mahalanobis matrix
    mean_matrix[i, ] <- apply(mahal_matrix_list[[i]], 2, mean)
  }
  
  return(mean_matrix)
}


# Debemos poner los mismos nombres de columna que hay en el resto de datos.

mean_matrix <- compute_row_means(result)
mean_matrix <- as.data.frame(mean_matrix)

colnames(mean_matrix) <- colnames(normalized_counts_filt_matrix_mean)

mean_matrix$Gene <- deseq_df_filt$Gene

mean_matrix <- mean_matrix[, c("Gene", setdiff(names(mean_matrix), "Gene"))] # Reordenamos para que la columna de genes sea la primera 

##################### Para clusterizar ######################################


# La función hkmeans() del paquete factoextra permite aplicar el método hierarchical K-means
set.seed(456)

hclust_matrix <- mean_matrix %>% dplyr::select(-Gene) %>%
  as.matrix()

rownames(hclust_matrix) <- normalized_counts_df_filt$Gene


hclust_matrix <- hclust_matrix %>%
  t() %>%
  scale() %>%
  t()

wss <- (nrow(hclust_matrix)-1)*sum(apply(hclust_matrix,2,var))
for (i in 2:20) wss[i] <- sum(kmeans(hclust_matrix,
                                     centers=i)$withinss)
plot(1:20, wss, type="b", xlab="Número de clusters",
     ylab="Suma de los errores cuadraticos")


hkmeans_cluster <- hkmeans(x = hclust_matrix, hc.metric = "euclidean",
                           hc.method = "complete", k = 6)

hkmeans_cluster <- hkmeans_cluster$cluster %>% 
  enframe() %>% 
  dplyr::rename(Gene = name, cluster = value)

head(hkmeans_cluster)

gene_cluster_df <- as.data.frame(hkmeans_cluster)

# Dataframe con las variables de interés
df_anotacion <- data.frame(time = metadata_mean$Time, condition = metadata_mean$Condition) 

# Crear anotaciones
anotacion <- HeatmapAnnotation(df = df_anotacion, show_annotation_name = FALSE)


Heatmap(matrix = hclust_matrix, name = "Z-score",
        clustering_distance_columns = "euclidean",
        clustering_distance_rows = "euclidean",
        clustering_method_columns = "complete",
        clustering_method_rows = "complete",
        split = hkmeans_cluster$cluster, show_row_names = FALSE,  column_names_gp = gpar(fontsize = 8))


ht <- Heatmap(matrix = hclust_matrix, name = "Z-score",
        clustering_distance_columns = "euclidean",
        clustering_distance_rows = "euclidean",
        clustering_method_columns = "complete",
        clustering_method_rows = "complete",
        split = hkmeans_cluster$cluster,
        cluster_columns = FALSE, # Comentar esta linea si no se quiere las muestras ordenadas.
        top_annotation = anotacion, show_row_names = FALSE,  column_names_gp = gpar(fontsize = 8), show_column_dend = FALSE)


ht

gene_cluster <- hkmeans_cluster

genes_cluster_1_mahal <- gene_cluster %>% filter(cluster==1)
genes_cluster_1_list_mahal <- genes_cluster_1_mahal %>% dplyr::select(Gene)
readr::write_csv(genes_cluster_1_list_mahal, "genes_cluster_1_mahal.csv")

genes_cluster_2_mahal <- gene_cluster %>% filter(cluster==2)
genes_cluster_2_list_mahal <- genes_cluster_2_mahal %>% dplyr::select(Gene)
readr::write_csv(genes_cluster_2_list_mahal, "genes_cluster_2_mahal.csv")

genes_cluster_3_mahal <- gene_cluster %>% filter(cluster==3)
genes_cluster_3_list_mahal <- genes_cluster_3_mahal %>% dplyr::select(Gene)
readr::write_csv(genes_cluster_3_list_mahal, "genes_cluster_3_mahal.csv")

genes_cluster_4_mahal <- gene_cluster %>% filter(cluster==4)
genes_cluster_4_list_mahal <- genes_cluster_4_mahal %>% dplyr::select(Gene)
readr::write_csv(genes_cluster_4_list_mahal, "genes_cluster_4_mahal.csv")

genes_cluster_5_mahal <- gene_cluster %>% filter(cluster==5)
genes_cluster_5_list_mahal <- genes_cluster_5_mahal %>% dplyr::select(Gene)
readr::write_csv(genes_cluster_5_list_mahal, "genes_cluster_5_mahal.csv")

genes_cluster_6_mahal <- gene_cluster %>% filter(cluster==6)
genes_cluster_6_list_mahal <- genes_cluster_6_mahal %>% dplyr::select(Gene)
readr::write_csv(genes_cluster_6_list_mahal, "genes_cluster_6_mahal.csv")

```

### Análisis de tendencias de los clusteres de mahalanobis

```{r}

trans_cts_cluster <- trans_cts_mean %>% 
  inner_join(hkmeans_cluster, by = "Gene")

head(trans_cts_cluster)

trans_cts_cluster %>%
  ggplot (aes(x=factor(time_stamp, level=c('Inflorescencia', 'Flor_cerrada', 'Flor_abierta', 'Fruto')), y=mean_cts_scaled)) +
  geom_line(aes(group = Gene), alpha = 0.3) +
  geom_line(stat = "summary", fun = "median", colour = "brown", size = 1.5, aes(group = 1)) +
  facet_grid(rows = vars(Condition), cols = vars(cluster)) +
  xlab('Tiempo')

```

## Gene ontology datos mahalanobis

```{r}
# Cuidado que se sobreescriben cosas con el anterior, luego hay que limpiar los datos!!!! Igual hay que hacerlo una funcion mejor :3

mart <- useMart(biomart="plants_mart", host="https://plants.ensembl.org")

listdatasets <- listDatasets(mart)
(listDatasets(mart))[grep("athaliana_eg_gene",listDatasets(mart)[,1]),]
athaliana_mart <- useMart(biomart = "plants_mart", host = "https://plants.ensembl.org", dataset = "athaliana_eg_gene"	)
listAttributes <- listAttributes(mart = athaliana_mart, page="feature_page")
listAttributes

attributes_to_retrieve = c("entrezgene_id", "external_gene_name", "name_1006", "go_id", "definition_1006")

all_athaliana_genes <- biomartr::biomart(genes = deseq_df2$Gene, mart = "plants_mart",   dataset = "athaliana_eg_gene",  attributes = attributes_to_retrieve, filters =  "ensembl_gene_id" )  

all_athaliana_genes$entrezgene_id = as.character(all_athaliana_genes$entrezgene_id) 
attributes_annotation = c("description", "tair_symbol")

resdata_annotation <- biomartr::biomart(genes = gene_cluster$Gene, mart = "plants_mart",   dataset = "athaliana_eg_gene",  attributes = attributes_annotation, filters =  "ensembl_gene_id" )  

resdata_annotationClean <- resdata_annotation[!duplicated(resdata_annotation$ensembl_gene_id),]
resdata_annotationClean

resdata_with_annotation <- merge(gene_cluster,resdata_annotationClean, by.x = "Gene", by.y= "ensembl_gene_id" )

write.table(resdata_with_annotation, file = paste(projPath,  "/resdata_with_annotation.csv", sep = "/"),  sep = ',', row.names = FALSE)

DT::datatable(resdata_with_annotation, class = 'cell-border stripe', editable = TRUE,extensions = 'Buttons', options = list(dom = 'Bfrtip', buttons = c('copy', 'csv', 'excel', 'pdf', 'print')), filter = "top", rownames = F)

```

### Cluster 1:

```{r}

cluster_1_athaliana_genes_annotated<- biomartr::biomart(genes = genes_cluster_1_mahal$Gene,                  # genes were retrieved using biomartr::getGenome()
                                mart = "plants_mart",                     # marts were selected with biomartr::getMarts()
                                dataset = "athaliana_eg_gene",               # datasets were selected with biomartr::getDatasets()
                                attributes = attributes_to_retrieve,            # attributes were selected with biomartr::getAttributes()
                                filters =   "ensembl_gene_id" )
head(cluster_1_athaliana_genes_annotated)  

ora_analysis_bp <- enrichGO(gene = cluster_1_athaliana_genes_annotated$entrezgene_id, 
                            universe = all_athaliana_genes$entrezgene_id, 
                            OrgDb = a_thaliana,  
                            keyType = "ENTREZID",
                            ont = "BP",              
                            pAdjustMethod = "BH",
                            qvalueCutoff = 0.05,
                            readable = TRUE, 
                            pool = FALSE)

ora_analysis_bp_simplify <- clusterProfiler::simplify(ora_analysis_bp, cutoff=0.6, by="p.adjust", select_fun=min)

ora_analysis_bp_df_C1 <- ora_analysis_bp@result  %>% tibble::rownames_to_column("GO") %>% filter(p.adjust<=0.05)
readr::write_csv(ora_analysis_bp_df_C1, "ora_analysis_athaliana_res_cluster_1_entrezid.csv")

DT::datatable(ora_analysis_bp_df_C1, class = 'cell-border stripe', editable = TRUE,extensions = 'Buttons', options = list(dom = 'Bfrtip', buttons = c('copy', 'csv', 'excel', 'pdf', 'print')), filter = "top", rownames = F)

barplot(ora_analysis_bp_simplify, 
        drop = TRUE, 
        showCategory = 10, 
        title = "Procesos biológicos GO - Mahal 1",
        font.size = 14)

```

### Cluster 2:

```{r}
cluster_2_athaliana_genes_annotated<- biomartr::biomart(genes = genes_cluster_2_mahal$Gene,                  # genes were retrieved using biomartr::getGenome()
                                mart = "plants_mart",                     # marts were selected with biomartr::getMarts()
                                dataset = "athaliana_eg_gene",               # datasets were selected with biomartr::getDatasets()
                                attributes = attributes_to_retrieve,            # attributes were selected with biomartr::getAttributes()
                                filters =   "ensembl_gene_id" )
head(cluster_2_athaliana_genes_annotated)  

ora_analysis_bp <- enrichGO(gene = cluster_2_athaliana_genes_annotated$entrezgene_id, 
                            universe = all_athaliana_genes$entrezgene_id, 
                            OrgDb = a_thaliana,  
                            keyType = "ENTREZID",
                            ont = "BP",              
                            pAdjustMethod = "BH",
                            qvalueCutoff = 0.05,
                            readable = TRUE, 
                            pool = FALSE)


ora_analysis_bp_simplify <- clusterProfiler::simplify(ora_analysis_bp, cutoff=0.6, by="p.adjust", select_fun=min)

ora_analysis_bp_df_C2 <- ora_analysis_bp@result  %>% tibble::rownames_to_column("GO") %>% filter(p.adjust<=0.05)
readr::write_csv(ora_analysis_bp_df_C2, "ora_analysis_athaliana_res_cluster_2_entrezid.csv")

DT::datatable(ora_analysis_bp_df_C2, class = 'cell-border stripe', editable = TRUE,extensions = 'Buttons', options = list(dom = 'Bfrtip', buttons = c('copy', 'csv', 'excel', 'pdf', 'print')), filter = "top", rownames = F)

barplot(ora_analysis_bp_simplify, 
        drop = TRUE, 
        showCategory = 10, 
        title = "Procesos biológicos GO - Mahal 2",
        font.size = 14)

```

### Cluster 3:

```{r}

cluster_3_athaliana_genes_annotated<- biomartr::biomart(genes = genes_cluster_3_mahal$Gene,                  # genes were retrieved using biomartr::getGenome()
                                mart = "plants_mart",                     # marts were selected with biomartr::getMarts()
                                dataset = "athaliana_eg_gene",               # datasets were selected with biomartr::getDatasets()
                                attributes = attributes_to_retrieve,            # attributes were selected with biomartr::getAttributes()
                                filters =   "ensembl_gene_id" )
head(cluster_3_athaliana_genes_annotated)  

ora_analysis_bp <- enrichGO(gene = cluster_3_athaliana_genes_annotated$entrezgene_id, 
                            universe = all_athaliana_genes$entrezgene_id, 
                            OrgDb = a_thaliana,  
                            keyType = "ENTREZID",
                            ont = "BP",              
                            pAdjustMethod = "BH",
                            qvalueCutoff = 0.05,
                            readable = TRUE, 
                            pool = FALSE)



ora_analysis_bp_simplify <- clusterProfiler::simplify(ora_analysis_bp, cutoff=0.6, by="p.adjust", select_fun=min)

ora_analysis_bp_df_C3 <- ora_analysis_bp@result  %>% tibble::rownames_to_column("GO") %>% filter(p.adjust<=0.05)
readr::write_csv(ora_analysis_bp_df_C3, "ora_analysis_athaliana_res_cluster_3_entrezid.csv")

DT::datatable(ora_analysis_bp_df_C3, class = 'cell-border stripe', editable = TRUE,extensions = 'Buttons', options = list(dom = 'Bfrtip', buttons = c('copy', 'csv', 'excel', 'pdf', 'print')), filter = "top", rownames = F)

# barplot(ora_analysis_bp_simplify, 
#         drop = TRUE, 
#         showCategory = 30, 
#         title = "Procesos biológicos GO - Mahal 3",
#         font.size = 7


```

### Cluster 4:

```{r}

cluster_4_athaliana_genes_annotated<- biomartr::biomart(genes = genes_cluster_4_mahal$Gene,                  # genes were retrieved using biomartr::getGenome()
                                mart = "plants_mart",                     # marts were selected with biomartr::getMarts()
                                dataset = "athaliana_eg_gene",               # datasets were selected with biomartr::getDatasets()
                                attributes = attributes_to_retrieve,            # attributes were selected with biomartr::getAttributes()
                                filters =   "ensembl_gene_id" )
head(cluster_4_athaliana_genes_annotated)  

ora_analysis_bp <- enrichGO(gene = cluster_4_athaliana_genes_annotated$entrezgene_id, 
                            universe = all_athaliana_genes$entrezgene_id, 
                            OrgDb = a_thaliana,  
                            keyType = "ENTREZID",
                            ont = "BP",             
                            pAdjustMethod = "BH",
                            qvalueCutoff = 0.05,
                            readable = TRUE, 
                            pool = FALSE)

ora_analysis_bp_simplify <- clusterProfiler::simplify(ora_analysis_bp, cutoff=0.6, by="p.adjust", select_fun=min)

ora_analysis_bp_df_C4 <- ora_analysis_bp@result  %>% tibble::rownames_to_column("GO") %>% filter(p.adjust<=0.05)
readr::write_csv(ora_analysis_bp_df_C4, "ora_analysis_athaliana_res_cluster_4_entrezid.csv")

DT::datatable(ora_analysis_bp_df_C4, class = 'cell-border stripe', editable = TRUE,extensions = 'Buttons', options = list(dom = 'Bfrtip', buttons = c('copy', 'csv', 'excel', 'pdf', 'print')), filter = "top", rownames = F)

barplot(ora_analysis_bp_simplify, 
        drop = TRUE, 
        showCategory = 10, 
        title = "Procesos biológicos GO - Mahal 4",
        font.size = 14)


```

### Cluster 5:

```{r}
cluster_5_athaliana_genes_annotated<- biomartr::biomart(genes = genes_cluster_5_mahal$Gene,                  # genes were retrieved using biomartr::getGenome()
                                mart = "plants_mart",                     # marts were selected with biomartr::getMarts()
                                dataset = "athaliana_eg_gene",               # datasets were selected with biomartr::getDatasets()
                                attributes = attributes_to_retrieve,            # attributes were selected with biomartr::getAttributes()
                                filters =   "ensembl_gene_id" )
head(cluster_5_athaliana_genes_annotated)  

ora_analysis_bp <- enrichGO(gene = cluster_5_athaliana_genes_annotated$entrezgene_id, 
                            universe = all_athaliana_genes$entrezgene_id, 
                            OrgDb = a_thaliana,  
                            keyType = "ENTREZID",
                            ont = "BP",             
                            pAdjustMethod = "BH",
                            qvalueCutoff = 0.05,
                            readable = TRUE, 
                            pool = FALSE)

ora_analysis_bp_simplify <- clusterProfiler::simplify(ora_analysis_bp, cutoff=0.6, by="p.adjust", select_fun=min)

ora_analysis_bp_df_C5 <- ora_analysis_bp@result  %>% tibble::rownames_to_column("GO") %>% filter(p.adjust<=0.05)
readr::write_csv(ora_analysis_bp_df_C5, "ora_analysis_athaliana_res_cluster_5_entrezid.csv")

DT::datatable(ora_analysis_bp_df_C5, class = 'cell-border stripe', editable = TRUE,extensions = 'Buttons', options = list(dom = 'Bfrtip', buttons = c('copy', 'csv', 'excel', 'pdf', 'print')), filter = "top", rownames = F)

barplot(ora_analysis_bp_simplify, 
        drop = TRUE, 
        showCategory = 10, 
        title = "Procesos biológicos GO - Mahal 5",
        font.size = 14)


```

### Cluster 6:

```{r}

cluster_6_athaliana_genes_annotated<- biomartr::biomart(genes = genes_cluster_6_mahal$Gene,                  # genes were retrieved using biomartr::getGenome()
                                mart = "plants_mart",                     # marts were selected with biomartr::getMarts()
                                dataset = "athaliana_eg_gene",               # datasets were selected with biomartr::getDatasets()
                                attributes = attributes_to_retrieve,            # attributes were selected with biomartr::getAttributes()
                                filters =   "ensembl_gene_id" )
head(cluster_6_athaliana_genes_annotated)  

ora_analysis_bp <- enrichGO(gene = cluster_6_athaliana_genes_annotated$entrezgene_id, 
                            universe = all_athaliana_genes$entrezgene_id, 
                            OrgDb = a_thaliana, 
                            keyType = "ENTREZID",
                            ont = "BP",              
                            pAdjustMethod = "BH",
                            qvalueCutoff = 0.05,
                            readable = TRUE, 
                            pool = FALSE)

ora_analysis_bp_simplify <- clusterProfiler::simplify(ora_analysis_bp, cutoff=0.6, by="p.adjust", select_fun=min)

ora_analysis_bp_df_C6 <- ora_analysis_bp@result  %>% tibble::rownames_to_column("GO") %>% filter(p.adjust<=0.05)
readr::write_csv(ora_analysis_bp_df_C6, "ora_analysis_athaliana_res_cluster_6_entrezid.csv")

DT::datatable(ora_analysis_bp_df_C6, class = 'cell-border stripe', editable = TRUE,extensions = 'Buttons', options = list(dom = 'Bfrtip', buttons = c('copy', 'csv', 'excel', 'pdf', 'print')), filter = "top", rownames = F)

barplot(ora_analysis_bp_simplify, 
        drop = TRUE, 
        showCategory = 10, 
        title = "Procesos biológicos GO - Mahal 6",
        font.size = 14)

```

## Clustering Mahalanobis distances

Con todas las réplicas. Nos ha servido para ver si hay alguna muestra outlier pero parece que no es muy de fiar por el momento

```{r}
# Cargamos los datos otra vez si hacen falta
# data_file <- file.path(projPath, "counts_todo.csv")
# 
# metadata_file <- file.path(projPath, "Metadata_todo.csv")

# Del data frame de counts filtradas debemos quitarle la columna de "gene" que da nombre a los genes para que todo sea numérico. También debemos pasarla a matriz.

normalized_counts_filt_matrix <- as.matrix(normalized_counts_df_filt[, !(names(normalized_counts_df_filt) == "Gene")])


# Funcion para hacer la distancia de mahalanobis en una linea
compute_mahalanobis_row <- function(row) {
  n <- length(row)
  var_row <- var(row) 
  dist_matrix <- matrix(0, n, n)  # Inicializamos la matriz de distancias vacia
  
  # Calculamos las ditancias
  for (i in 1:n) {
    for (j in 1:n) {
      dist_matrix[i, j] <- (row[i] - row[j])^2 / var_row  # Apicamos la formula de mahalanobis (dividiendo entre la varianza de toda la fila)
    }
  }
  
  return(dist_matrix)
}

# Aplicamos la funcoion a cada fila
result <- lapply(1:nrow(normalized_counts_filt_matrix), function(i) compute_mahalanobis_row(normalized_counts_filt_matrix[i, ]))


###################################################################################
# Creamos una nueva matriz vacia en la que ir añadendo los resultados
# En esta matriz: por cada lina que creamos en la matriz nueva. cada valor debe ser la suma de la fila que le corresponde entre los valores que hay ( la media de los valores) 


# Hacemos la media de cada linea de las matrices de distancia de Mahalanobis.
compute_row_means <- function(mahal_matrix_list) {
  # Tenemos una matriz vacía para guardar las medias
  num_rows <- length(mahal_matrix_list) # Elo numero ed líneas debe coincidir con el numero de matrices de distancias que tenemos, que será igual a nuestro numero de genes  (cada linea seria un gen)
  num_cols <- ncol(mahal_matrix_list[[1]]) # El número de columnas será las diferentes condiciones que tenemos
  
  mean_matrix <- matrix(0, nrow = num_rows, ncol = num_cols) # Cremos una matriz vacia para los datos
  
  for (i in 1:num_rows) {
    mean_matrix[i, ] <- apply(mahal_matrix_list[[i]], 2, mean)
  }
  
  return(mean_matrix)
}

# Aplicamos la funcion para crear la mnatriz nueva con las distancias usando la lista de resultados de las matrices creadas anteriormente.  

# Debemos poner los mismos nombres de columna que hay en el resto de datos.

mean_matrix <- compute_row_means(result)
mean_matrix <- as.data.frame(mean_matrix)

colnames(mean_matrix) <- colnames(normalized_counts_filt_matrix)

mean_matrix$Gene <- deseq_df_filt$Gene

mean_matrix <- mean_matrix[, c("Gene", setdiff(names(mean_matrix), "Gene"))] # Reordenamos para que la columna de genes sea la primera 

# mean_matrix <- mean_matrix[rownames(mean_matrix) %in% deseq_df_filt$Gene, ]

# print(mean_matrix)


```

```{r}
# La función hkmeans() del paquete factoextra permite aplicar el método hierarchical K-means
set.seed(789)


hclust_matrix <- mean_matrix %>% dplyr::select(-Gene) %>% 
  as.matrix()

rownames(hclust_matrix) <- normalized_counts_df_filt$Gene

hclust_matrix <- hclust_matrix %>%
  t() %>%
  scale() %>%
  t()

wss <- (nrow(hclust_matrix)-1)*sum(apply(hclust_matrix,2,var))
for (i in 2:20) wss[i] <- sum(kmeans(hclust_matrix,
                                     centers=i)$withinss)
plot(1:20, wss, type="b", xlab="Número de clusters",
     ylab="Suma del error cuadrático")


hkmeans_cluster <- hkmeans(x = hclust_matrix, hc.metric = "euclidean",
                           hc.method = "complete", k = 6)

hkmeans_cluster <- hkmeans_cluster$cluster %>% 
  enframe() %>% 
  dplyr::rename(Gene = name, cluster = value)


head(hkmeans_cluster)

gene_cluster_df <- as.data.frame(hkmeans_cluster)

# Dataframe con las variables de interés
df_anotacion <- data.frame(time = metadata$Time, condition = metadata$Condition) 

# Crear anotaciones
anotacion <- HeatmapAnnotation(df = df_anotacion, show_annotation_name = FALSE)

Heatmap(matrix = hclust_matrix, name = "Z-score",
        clustering_distance_columns = "euclidean",
        clustering_distance_rows = "euclidean",
        clustering_method_columns = "complete",
        clustering_method_rows = "complete",
        split = hkmeans_cluster$cluster, show_row_names = FALSE,  column_names_gp = gpar(fontsize = 8))

ht <- Heatmap(matrix = hclust_matrix, name = "Z-score",
        clustering_distance_columns = "euclidean",
        clustering_distance_rows = "euclidean",
        clustering_method_columns = "complete",
        clustering_method_rows = "complete",
        cluster_columns = FALSE,
        split = hkmeans_cluster$cluster,
        top_annotation = anotacion, show_row_names = FALSE,  column_names_gp = gpar(fontsize = 8), show_column_dend = FALSE)


ht

```

# UPSET PLOT comparativa.

Para comparar los genes que hemos obtenido en los clusters de mahalanobis comparados con el los que obtenemos con counts. Nos crea una gráfica con las interacciones de cada uno de los clusters generados con la matriz de counts con cada uno de los que se genera con la matriz de distancias.

Creamos las listas necesarias para UpSet plot.

```{r}
# Lista que contiene los genes los clusters de Mahalanobis y counts.
lt <- list(
  counts1 = as.character(genes_cluster_1_list$Gene),  
  mahal1 = as.character(genes_cluster_1_list_mahal$Gene),
  counts2 = as.character(genes_cluster_2_list$Gene),  
  mahal2 = as.character(genes_cluster_2_list_mahal$Gene),
  counts3 = as.character(genes_cluster_3_list$Gene),  
  mahal3 = as.character(genes_cluster_3_list_mahal$Gene),
  counts4 = as.character(genes_cluster_4_list$Gene),  
  mahal4 = as.character(genes_cluster_4_list_mahal$Gene),
  counts5 = as.character(genes_cluster_5_list$Gene),  
  mahal5 = as.character(genes_cluster_5_list_mahal$Gene),
  counts6 = as.character(genes_cluster_6_list$Gene),  
  mahal6 = as.character(genes_cluster_6_list_mahal$Gene)  
)
# Pasamos la lista a una matrix
list_to_matrix(lt) 

```

```{r}
# Generamos las gráficas

#m1 = make_comb_mat(lt, mode = "distinct")
m2 = make_comb_mat(lt, mode = "intersect") # elegimos el modo intersect
#m3 = make_comb_mat(lt2, mode = "intersect")


#UpSet(m1)
UpSet(m2)
#UpSet(m3)

```

# DATOS PARA WGCNA

Seleccionar los datos que se quieran usar para WGCNA.

```{r}
# # DATOS PARA WGCNA 
# normalized_counts_df_filt_2 <- normalized_counts_df_filt
# 
# counst_cluster_2 <- normalized_counts_df_filt_2[normalized_counts_df_filt_2$Gene %in% genes_cluster_2$Gene, ]
# 
# directory <- "C:/Users/Sara/Desktop/Datos experimento/WGCNA/"  
# file_path <- paste0(directory, "normalized_counts_df_filt_3.csv")
# 
# write.csv(normalized_counts_df_filt_2, file_path, row.names = FALSE)
```
